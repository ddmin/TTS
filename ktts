#!/usr/bin/python3
# ktts (聞tts): converts text file into mp3

# TODO: click
# TODO: separate pages with ##Page 1## -> into chapters
# TODO: dump pdf text -> txt file -> $EDITOR txt -> mimic3 -> mpv
# TODO: dump pdf text -> txt file -> $EDITOR txt -> mimic3 -> mpv
# TODO: sanitize - test bracketed words

# TODO: concat files
# https://superuser.com/questions/314239/how-to-join-merge-many-mp3-files

# TODO: ffmpeg get duration
# https://stackoverflow.com/questions/6239350/how-to-extract-duration-time-from-ffmpeg-output

# TODO: https://community.openconversational.ai/t/how-to-use-mimic3-directly-from-python-code/12778


from concurrent.futures import ThreadPoolExecutor, as_completed
import subprocess
import pdftotext
import click
import tqdm
import uuid
import os

SAVE_DIRECTORY = "/tmp/ktts"


def get_wav_length(wav_file):
    """Return the duration of a wav file"""
    wav_length_cmd = (
        f'ffprobe -i {wav_file} -show_entries format=duration -v quiet -of csv="p=0"'
    )
    output = subprocess.Popen(
        wav_length_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE
    )
    wav_length, _ = output.communicate()
    return wav_length


def generate_tts_files(page_names, page_contents):
    """Generate tts (wav) files for each page"""
    progress = tqdm.tqdm(total=len(page_names), desc="Generating TTS")

    wavs = {}
    with ThreadPoolExecutor(max_workers=5) as executor:
        for page, page_content in zip(page_names, page_contents):

            def mimic_worker():
                wavs[page] = generate_tts(page_content)

            futures = [executor.submit(mimic_worker)]

            for future in as_completed(futures):
                future.result()
                progress.update(n=1)

    return wavs


def write_file(text):
    """Write text to a temporary txt file."""
    output = f"{SAVE_DIRECTORY}/{unique_identifier()}.txt"
    with open(output, "w") as f:
        f.write(text)

    return output


def generate_tts(text):
    """Use mimic3 to generate wav files."""
    output = f"{SAVE_DIRECTORY}/{unique_identifier()}.wav"
    text_file = write_file(text)

    text = subprocess.Popen(["cat", text_file], stdout=subprocess.PIPE)
    sanitize = subprocess.Popen(["sanitize"], stdin=text.stdout, stdout=subprocess.PIPE)
    with open(output, "w") as f:
        mimic = subprocess.Popen(
            ["mimic3", "--voice", "en_US/vctk_low#p276"],
            stdin=sanitize.stdout,
            stdout=f,
            stderr=subprocess.DEVNULL,
        )
        mimic.wait()
    return output


def setup(save_file_name):
    """Setup related processes."""

    # create save directory
    if not os.path.exists(SAVE_DIRECTORY):
        os.mkdir(SAVE_DIRECTORY)


def unique_identifier():
    """Return unique filename identifier."""
    return uuid.uuid4().hex


@click.command()
@click.argument("file", type=click.File("rb"), nargs=1)
def main(file):
    save_file_name = ".".join(file.name.split(".")[:-1]) + ".wav"
    setup(save_file_name)

    if file.name[-3:] == "pdf":
        pdf = pdftotext.PDF(file)
        text = "".join([f"###{page+1}###" + pdf[page] for page in range(len(pdf))])
    else:
        text = file.read().decode()

    # separate pages
    pages = text.split("###")
    pages = list(filter(lambda x: x, pages))

    # multiple pages
    if not len(pages) < 2:
        if len(pages) % 2 == 0:
            page_names = [pages[n] for n in range(0, len(pages), 2)]
            page_contents = [pages[n] for n in range(1, len(pages), 2)]
        else:
            raise click.UsageError(
                f"'{file.name}' does not have corresponding pages and page numbers."
            )
    else:
        page_names = [file.name]
        page_contents = pages

    assert len(page_names) == len(page_contents)

    wavs = generate_tts_files(page_names, page_contents)

    print(page_names)  # REMOVE
    print(wavs)  # REMOVE

    concat_file = ""
    wav_lengths = []
    for page in page_names:
        wav_file = wavs[page]

        wav_lengths.append(get_wav_length(wav_file))
        concat_file += f"file '{wav_file}'\n"

    wav_lengths = list(map(lambda x: float(x), wav_lengths))
    print(wav_lengths)  # REMOVE

    concat_file = concat_file[:-1]

    wav_list = f"{SAVE_DIRECTORY}/wav-list.txt"
    with open(wav_list, "w") as f:
        f.write(concat_file)

    concat_cmd = (
        f"ffmpeg -v quiet -f concat -safe 0 -i {wav_list} -c copy {save_file_name}"
    )
    subprocess.run(concat_cmd, shell=True)


if __name__ == "__main__":
    main()
